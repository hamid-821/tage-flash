#summary This is a tutorial game for the game engine TAGE.

=Introduction=

In this tutorial, I will try to walk you through programming a sample game with TAGE. I will try to show all the features of the game engine.

==1. Creating the Interface and the Engine==

First, we need an engine to simulate the game. Engine is the main component of the engine. All it does is accepting input commands as string and returning an answer as output. The output is sent by an event, rather than returning a string.

{{{
var engine:Engine = new Engine();
engine.addEventListener(OutputMessageEvent.OUTPUT_MESSAGE, outputMessage);
}}}

We also need an interface to receive input and show output. For this tutorial, I will use the Console class included in the engine.

{{{
console = new Console();
addChild(console);
console.addEventListener(NewMessageEvent.NEW_MESSAGE, newMessage);
}}}

Here are the codes for the event handlers:

{{{
public function newMessage(e:NewMessageEvent):void {
	var text:String = e.text;
	console.println("> " + text);
	engine.parseCommand(text);
}

public function outputMessage(e:OutputMessageEvent):void {
	var text:String = e.message;
	console.print(text);
}
}}}

==2. Creating Scenes==

Scenes are what hold objects inside and create a scenery in which the game is currently played. The player can interact with objects in the current scene.

For this demo, we will create three scenes.

{{{
var sceneMainRoom:Scene = new Scene();
sceneMainRoom.addAlias("main room", "room");
sceneMainRoom.descriptionShort = "I'm in a room.";
sceneMainRoom.descriptionLong = "I'm in a room. I don't remember how I ended up here.";

var sceneSmallRoom:Scene = new Scene();
sceneSmallRoom.addAlias("small room", "room", "little room");
sceneSmallRoom.descriptionLong = "This is a small room, put here just to show you the scene changing feature of the engine.";
sceneSmallRoom.descriptionShort = "This is a small room.";
sceneSmallRoom.addNeighborScene(sceneMainRoom);
sceneMainRoom.addNeighborScene(sceneSmallRoom);

var sceneWin:Scene = new Scene();
sceneWin.descriptionShort = "I'm in a garden full of people.";
sceneWin.descriptionLong = "I'm in a nicely decorated garden. There are many people here, celebrating my arrival, and congratulating me. And I lived happily ever after.";
}}}

addAlias adds aliases (names) for the scene. the player can refer to the scene with one of these names, for example while coming to this room from another place. when the player says "go to room" or "go to main room", both commands will work.

descriptionShort is the short description that is showed when the player wants to describe the room. descriptionLong is printed the first time the player enters the room.

addNeighborScene adds a neighbor to the scene. The player can go from a scene to its neighbors.

==3. Creating the Character==

The game must have one character to be played. It's just an item with inventory.

{{{
var character:Character = new Character();
character.addAlias("me", "myself", "Guybrush", "Guybrush Threepwood");
character.shortDescription = "I'm in my mid-twenties and I look so good that it is probably the reason why they have locked me up in here; to save the world from getting blind by my awesome look.";
}}}

The methods and variables will be explained in the next section.

==4. Creating Items==

This is the longest part, so get ready. We will create items, define interactions with them, and add them to the scene. The interactions are added to the scene the objects belong to, because each time the player types a command, the required object will have to be searched in the current scene.

{{{
var table:Item = new Item();
table.addAlias("table");
table.shortDescription = "It's a table.";
sceneMainRoom.addItem(table);
}}}

The items have to be added to a scene (or to charcter's inventory - we'll come to that later) to be included in the game. 

Items have short description and additional description properties; additional description is useful for changeable properties of the object, for example if a door is open you may choose to have the description "It's a door. It's open.", and if it's closed, it will simply be "It's a door. It's closed". So the idea is, shortDescription = "It's a door.", and additionalDescription = "It's closed.". When the player opens the door, you simply assign additionalDescription to "It's open."

{{{
var pencil:Item = new Item();
pencil.isPickable = true;
pencil.addAlias("a pencil", "a pen");
pencil.shortDescription = "It's a pencil. Hmm.";
table.addItem(pencil);	

var note:Item = new Item();
note.isPickable = true;
note.addAlias("note", "notes", "paper");
note.shortDescription = "It's a note. Maybe it has some clues on why I am here and what is going on.";
table.addItem(note);	
}}}

isPickable property defines whether the object may be picked up by the player. We will come to commands later.

Here you see we add objects to another object, in this example we add a note and a pen to the table. So, these objects "belong to" table; they are described when the player looks at the table, they aren't described in the general description of the scene.

{{{
var cupboard:Item = new Item();
cupboard.addAlias("cupboard");
cupboard.shortDescription = "It's a cupboard.";
sceneMainRoom.addItem(cupboard);
cupboard.setProp("open", false);
}}}

setProp and getProp are two functions to add custom properties to your object, for customizing them. Here we use a custom property called "open", to detect whether the cupboard is opened or not.

{{{
var clothes:Item = new Item();
clothes.isPickable = true;
clothes.addAlias("cloth", "clothes");
clothes.shortDescription = "They are my clothes! No wonder why I was naked before.";
clothes.isVisible = false;
cupboard.addItem(clothes);
}}}

Here we set another property of items, isVisible. If an object is invisible, the player won't see it in descriptions. For example when a cupboard is closed, the objects inside it should be invisible.

{{{
var door:Item = new Item();
door.addAlias("door");
door.shortDescription = "It's a door.";
door.additionalDescription = "It seems like it's locked.";
door.setProp("open", false);
door.setProp("locked", true);
sceneMainRoom.addItem(door);

var telephone:Item = new Item();
telephone.addAlias("telephone", "phone");
telephone.shortDescription = "It's a telephone.";
telephone.additionalDescription = "It's ringing.";
telephone.setProp("ringing", true);
telephone.overridePickup = true;
table.addItem(telephone);

telephone.setTimer(7000, function() {
	engine.printLine("*Brrrrrr! (A phone rings)*");
}, 0);
}}}

Here we have a funny thing called overridePickup. Since the "pick up x" command is predefined in the engine, this variable is needed to override the engine's behaviour of pick up command. I use it here because "pick up phone" here means answering it, rather than actually picking it up. All the objects are unpickable by default, by the way.

We also set the timer delay and function of the timer of the item. Each item has a timer that you can use for your special purposes. Here we use it to simulate the ringing of the phone. Engine class has a function called startAllTimers(scene) and stopAllTimers(scene), which starts and stops all the timers in a scene. If you don't give any scene, all the timers are started or stopped, regardless of their scene. These functions include the timer of the character.

==5. Adding custom actions==

Actions are what define the game interaction. The player types in commands, such as "pick up/take x" or "look at/describe y" or "walk to/go to z". Besides, you can also allow custom commands, anything you want. You simply register your commands and their callback functions to the scene, and you are good to go. Here I will try to explain how it works. There are two methods, scene.setAction1 and scene.setAction2, the former being simpler than the latter.

Note: You can spare lots of time by using regex in your commands. The callback functions are called with (command:String, match:Array) pair, command being the formatted command of the player (useless spaces are removed, the command is made all lower case, the articles are removed, and so on), and match being the match array for the regex result matched with the player's command.

{{{
sceneMainRoom.setAction1(note, "(use|read)", function() {
	engine.printLine("Dear Sir,\n\nYou are probably wondering why you are here. Sorry for the inconvenience, but we had to bring you here for a special purpose. Please do not try to run away, for soon you will get to know the reason and the necessity of your presence.\n\nBest,\nAdministration");
});
}}}

Here we add a function to our scene for the note object. The command name is either use or read. So if the player types in "use x" or "read x", x being any one of the aliases of the note object, this function is called.

{{{
sceneMainRoom.setAction1(cupboard, "close", function() {
	if (cupboard.getProp("open") == false) {
		engine.printLine("It's already closed.");
	} else {
		cupboard.setProp("open", false);
		cupboard.additionalDescription = "";
		engine.printLine("Closed the cupboard.");
		for each(var i:Item in cupboard.items) {
			i.isVisible = false;
		}
	}
});
sceneMainRoom.setAction1(cupboard, "open", function() {
	if (cupboard.getProp("open") == true) {
		engine.printLine("It's already open.");
	} else {
		cupboard.setProp("open", true);
		cupboard.additionalDescription = "It's open.";
		engine.printLine("Opened the cupboard.");
		for each(var i:Item in cupboard.items) {
			i.isVisible = true;
		}
		engine.printLine(cupboard.itemsDescription);
	}
});
}}}

Here we added cupboard's actions.

{{{
sceneMainRoom.setAction1(clothes, "(use|put on|wear)", function() {
	if (!clothes.isVisible) {
		engine.printLine("I can't find the object.");
	}
	else {
		engine.printLine("I put on my clothes. It feels better to be dressed, even if I'm alone.");
		clothes.remove();
		engine.unregister(clothes);
	}
});
}}}

The actions for clothes object. Here we see the functions called "item.remove()" and "engine.unregister()". They are kind of self explanatory. When you call engine.unregister, there is no way to add that object to the game, unless you call engine.register; whereas when you call item.remove(), it only removes it from its owner.

{{{
sceneMainRoom.setAction1(door, "(enter|use)", function() {
	if (door.getProp("open") == false) {
		engine.printLine("It's closed.");
	} 
	else {
		engine.printLine("Wohoo, I'm free!");
		engine.printLine(SEPARATOR);
		engine.printLine("Thanks for playing the demo level. Hope you enjoyed it, and hope you enjoy the game engine!");
	}
});

sceneMainRoom.setAction1(door, "(unlock)", function() {
	engine.printLine("I can't unlock it with my bare hands. The instructions on the lock says that the door can be unlocked with a pencil. How convenient.");	
});
sceneMainRoom.setAction1(door, "(open)", function() {
	if (door.getProp("locked") == true) {
		engine.printLine("It's locked.");
	}
	else if (door.getProp("open") == true) {
		engine.printLine("It's already open.");
	}
	else {
		engine.printLine("Opened the door.");
		door.setProp("open", true);
		door.additionalDescription = "It's open.";
	}
});

sceneMainRoom.setAction1(door, "(close)", function() {
	if (door.getProp("open") == true) {
		door.setProp("open", false);
		engine.printLine("Closed the door.");
		door.additionalDescription = "";
	} else {
		engine.printLine("It's already closed.");
	}
});
}}}

The actions for the door object. We also make use of  the variable "additionalDescription" here.

{{{
sceneMainRoom.setAction2(openDoorFunc, "(unlock|open) $1 with $2", door, pencil);
sceneMainRoom.setAction2(openDoorFunc, "(use) $1 with $2", pencil, door);
}}}

This is the second set action function. it's more complicated; it lets you use multiple objects and label them with $1,2,3, etc. The parser will replace the dollars with all of the items' aliases with respect to the argument array. For example, "(unlock|open) $1 with $2", door, pencil means (unlock or open) + any one of the aliases of "door" + with + any one of the aliases of "pencil". You can use as many number of objects as you want. Below we will define openDoorFunc.

{{{
var openDoorFunc:Function = function() { 
	if (door.getProp("locked") == false) {
		engine.printLine("The door is already open.");
	} 
	else if (pencil.isPickedUp == false) { 
		engine.printLine("I don't have the object.");
	}
	else {
		door.setProp("locked", false);
		engine.printLine("Tadaa! The door is unlocked!");
		door.additionalDescription = "";
		
		engine.setState(sceneWin, character, sceneWin);
	}
};
}}}

Here we use engine.setState(nextScene, character, interactionHandler). What it does is it changes the scene to the next scene, the character to the given character, and the interaction handler to the 3rd argument. Now for some detail, every class is derived from ActionHandler class, which is simply a command parser and action caller. The interactionHandler in the engine controls the input output flow; so that whenever a new input comes, the engine runs the parse command of the interactionHandler, and it returns the result. So, the interaction can be handled by scenes, items, dialogue objects (which we will see soon), characters, NPC's, etc.

{{{

}}}